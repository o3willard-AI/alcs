/**
 * Coverage Parser Service
 *
 * Parses coverage reports from various test frameworks into a unified format.
 * Supports pytest, Jest, Go, JaCoCo (Java), and other coverage formats.
 */

import * as fs from 'fs/promises';
import { CoverageReport } from '../types/mcp';
import { logger } from './loggerService';

export class CoverageParser {
  /**
   * Parse pytest coverage.json file
   * Generated by: pytest --cov=module --cov-report=json
   */
  async parsePytestCoverage(jsonPath: string): Promise<CoverageReport> {
    try {
      const content = await fs.readFile(jsonPath, 'utf-8');
      const data = JSON.parse(content);

      // pytest-cov generates coverage.py format
      // Structure: { "totals": { "percent_covered": 85.5, ... }, "files": {...} }
      const totals = data.totals || {};

      const lineCoverage = totals.percent_covered || 0;
      const branchCoverage = totals.percent_covered_display
        ? parseFloat(totals.percent_covered_display)
        : lineCoverage; // Fallback to line coverage

      const linesCovered = totals.covered_lines || 0;
      const linesTotal = totals.num_statements || 0;

      // Extract uncovered lines from files
      const uncoveredLines: number[] = [];
      const files = data.files || {};
      for (const file of Object.values(files) as any[]) {
        const missing = file.missing_lines || [];
        uncoveredLines.push(...missing);
      }

      return {
        line_coverage: lineCoverage,
        branch_coverage: branchCoverage,
        function_coverage: totals.percent_covered || 0, // pytest doesn't separate function coverage
        lines_covered: linesCovered,
        lines_total: linesTotal,
        uncovered_lines: uncoveredLines,
      };
    } catch (error: any) {
      logger.error(`Failed to parse pytest coverage: ${error.message}`);
      return this.getZeroCoverage();
    }
  }

  /**
   * Parse Jest coverage JSON
   * Generated by: jest --coverage --json
   * Coverage is in the JSON output's "coverageMap" field
   */
  parseJestCoverage(coverageData: any): CoverageReport {
    try {
      // Jest coverage structure
      // coverageData can be the full jest result or just the coverage summary
      let summary = coverageData;

      // If this is a full jest result, extract coverage summary
      if (coverageData.coverageMap) {
        summary = this.extractJestCoverageSummary(coverageData.coverageMap);
      } else if (coverageData.total) {
        summary = coverageData.total;
      }

      const lines = summary.lines || {};
      const branches = summary.branches || {};
      const functions = summary.functions || {};

      return {
        line_coverage: lines.pct || 0,
        branch_coverage: branches.pct || 0,
        function_coverage: functions.pct || 0,
        lines_covered: lines.covered || 0,
        lines_total: lines.total || 0,
        uncovered_lines: this.extractJestUncoveredLines(summary),
      };
    } catch (error: any) {
      logger.error(`Failed to parse Jest coverage: ${error.message}`);
      return this.getZeroCoverage();
    }
  }

  /**
   * Parse Go test coverage output
   * Generated by: go test -cover -coverprofile=coverage.out
   */
  async parseGoCoverage(coverageOutput: string): Promise<CoverageReport> {
    try {
      // Go coverage output format:
      // "coverage: 85.5% of statements"
      const match = coverageOutput.match(/coverage:\s+([\d.]+)%/);

      if (!match) {
        logger.warn('Could not parse Go coverage percentage');
        return this.getZeroCoverage();
      }

      const coverage = parseFloat(match[1]);

      // Go doesn't provide detailed line-by-line coverage in simple output
      // For more detail, would need to parse coverage.out file
      return {
        line_coverage: coverage,
        branch_coverage: coverage, // Go doesn't separate branch coverage
        function_coverage: coverage,
        lines_covered: 0, // Would need coverage.out parsing
        lines_total: 0,
        uncovered_lines: [],
      };
    } catch (error: any) {
      logger.error(`Failed to parse Go coverage: ${error.message}`);
      return this.getZeroCoverage();
    }
  }

  /**
   * Parse Go coverage profile file (coverage.out)
   * More detailed than simple output
   */
  async parseGoCoverageProfile(profilePath: string): Promise<CoverageReport> {
    try {
      const content = await fs.readFile(profilePath, 'utf-8');
      const lines = content.split('\n').filter(l => l.trim() && !l.startsWith('mode:'));

      let totalStatements = 0;
      let coveredStatements = 0;

      for (const line of lines) {
        // Format: file.go:startLine.startCol,endLine.endCol numStmt count
        const parts = line.split(/\s+/);
        if (parts.length >= 3) {
          const numStmt = parseInt(parts[1], 10);
          const count = parseInt(parts[2], 10);

          totalStatements += numStmt;
          if (count > 0) {
            coveredStatements += numStmt;
          }
        }
      }

      const coverage = totalStatements > 0
        ? (coveredStatements / totalStatements) * 100
        : 0;

      return {
        line_coverage: coverage,
        branch_coverage: coverage,
        function_coverage: coverage,
        lines_covered: coveredStatements,
        lines_total: totalStatements,
        uncovered_lines: [],
      };
    } catch (error: any) {
      logger.error(`Failed to parse Go coverage profile: ${error.message}`);
      return this.getZeroCoverage();
    }
  }

  /**
   * Parse JaCoCo XML coverage report (Java)
   * Generated by: mvn test with JaCoCo plugin
   */
  async parseJacocoCoverage(xmlPath: string): Promise<CoverageReport> {
    try {
      const content = await fs.readFile(xmlPath, 'utf-8');

      // Simple XML parsing for counters
      // Format: <counter type="LINE" missed="10" covered="90"/>
      const lineMatch = content.match(/<counter type="LINE" missed="(\d+)" covered="(\d+)"\/>/);
      const branchMatch = content.match(/<counter type="BRANCH" missed="(\d+)" covered="(\d+)"\/>/);
      const methodMatch = content.match(/<counter type="METHOD" missed="(\d+)" covered="(\d+)"\/>/);

      let lineCoverage = 0;
      let linesCovered = 0;
      let linesTotal = 0;

      if (lineMatch) {
        const missed = parseInt(lineMatch[1], 10);
        const covered = parseInt(lineMatch[2], 10);
        linesTotal = missed + covered;
        linesCovered = covered;
        lineCoverage = linesTotal > 0 ? (covered / linesTotal) * 100 : 0;
      }

      let branchCoverage = lineCoverage;
      if (branchMatch) {
        const missed = parseInt(branchMatch[1], 10);
        const covered = parseInt(branchMatch[2], 10);
        const total = missed + covered;
        branchCoverage = total > 0 ? (covered / total) * 100 : 0;
      }

      let functionCoverage = lineCoverage;
      if (methodMatch) {
        const missed = parseInt(methodMatch[1], 10);
        const covered = parseInt(methodMatch[2], 10);
        const total = missed + covered;
        functionCoverage = total > 0 ? (covered / total) * 100 : 0;
      }

      return {
        line_coverage: lineCoverage,
        branch_coverage: branchCoverage,
        function_coverage: functionCoverage,
        lines_covered: linesCovered,
        lines_total: linesTotal,
        uncovered_lines: [],
      };
    } catch (error: any) {
      logger.error(`Failed to parse JaCoCo coverage: ${error.message}`);
      return this.getZeroCoverage();
    }
  }

  /**
   * Extract coverage summary from Jest coverage map
   */
  private extractJestCoverageSummary(coverageMap: any): any {
    const summary = {
      lines: { total: 0, covered: 0, pct: 0 },
      branches: { total: 0, covered: 0, pct: 0 },
      functions: { total: 0, covered: 0, pct: 0 },
      statements: { total: 0, covered: 0, pct: 0 },
    };

    for (const file of Object.values(coverageMap) as any[]) {
      if (file.lines) {
        summary.lines.total += file.lines.total || 0;
        summary.lines.covered += file.lines.covered || 0;
      }
      if (file.branches) {
        summary.branches.total += file.branches.total || 0;
        summary.branches.covered += file.branches.covered || 0;
      }
      if (file.functions) {
        summary.functions.total += file.functions.total || 0;
        summary.functions.covered += file.functions.covered || 0;
      }
      if (file.statements) {
        summary.statements.total += file.statements.total || 0;
        summary.statements.covered += file.statements.covered || 0;
      }
    }

    // Calculate percentages
    summary.lines.pct = summary.lines.total > 0
      ? (summary.lines.covered / summary.lines.total) * 100
      : 0;
    summary.branches.pct = summary.branches.total > 0
      ? (summary.branches.covered / summary.branches.total) * 100
      : 0;
    summary.functions.pct = summary.functions.total > 0
      ? (summary.functions.covered / summary.functions.total) * 100
      : 0;

    return summary;
  }

  /**
   * Extract uncovered line numbers from Jest coverage
   */
  private extractJestUncoveredLines(summary: any): number[] {
    const uncovered: number[] = [];

    // Jest coverage includes line numbers in the data
    if (summary.lines && summary.lines.uncovered) {
      uncovered.push(...summary.lines.uncovered);
    }

    return uncovered;
  }

  /**
   * Return zero coverage report
   */
  private getZeroCoverage(): CoverageReport {
    return {
      line_coverage: 0,
      branch_coverage: 0,
      function_coverage: 0,
      lines_covered: 0,
      lines_total: 0,
      uncovered_lines: [],
    };
  }
}

// Export singleton instance
export const coverageParser = new CoverageParser();
